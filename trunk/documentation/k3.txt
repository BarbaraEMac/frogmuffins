												becmacdo	Barbara Macdonald
												dgoc 		Daniel Goc

 	     __  __                                ___          __     
		/\ \/\ \                              /\_ \       /'__`\   
		\ \ \/'/'     __   _ __    ___      __\//\ \     /\_\L\ \  
		 \ \ , <    /'__`\/\`'__\/' _ `\  /'__`\\ \ \    \/_/_\_<_ 
		  \ \ \\`\ /\  __/\ \ \/ /\ \/\ \/\  __/ \_\ \_    /\ \L\ \
		   \ \_\ \_\ \____\\ \_\ \ \_\ \_\ \____\/\____\   \ \____/
		    \/_/\/_/\/____/ \/_/  \/_/\/_/\/____/\/____/    \/___/ 

Question 1
==========
	The executable is located at: /u8/becmacdonald/cs452/a3/handin/main/main.elf.

	To make the kernel, execute the following from the root directory:
	cd src/
	make clean && make all && make copy
	cd ..
	make clean && make all
	cp main/main.elf /u/cs452/tftpboot/ARM/becmacdo_a3.elf

	To load the program, type 'load ARM/becmacdo_a3.elf' at the command prompt.

	Finally, to operate the program, type 'go' at the RedBoot command prompt.

Question 2 
==========
	
	Weaknesses in Previous Kernel That We Fixed
	===========================================
	context switch


	TD and TD Manager
	=================
	We made a few changes to our task descriptor (TD) struct and manager (TDM).
	We added a new TD state AWAITING_EVT to indicate that a task is blocked and
	waiting for a particular event. Tasks with this state will not be put on a 
	ready queue or scheduled to be active until the event has occurred.

	We also changed the name of our task descriptor manager. It used to be
	called PQ since it just held priority queue operations for the ready queue.
	Now that it has device drive information, the ready queues and the 
	await event queues, we've changed the name to TDM (which stands for TD Manager).

	Context Switch
	==============
	
	
	Interrupt Handling
	==================


	Device Drivers
	==============
	How do they work? What do they do? Why do we have them?
	
	Await Event
	===========
	AwaitEvent() can be called by a user task to block the task until a particular 
	event has occurred. Since this is a system call, the handler for AwaitEvent()
	calls swi with the corresponding code (9) for this type of system call as a 
	single argument.
	
	Here is the pseudo code for kernel code of awaitEvent():
		Ensure that the arguments are correct.
			Event Id is valid.
			The driver for this event id has been installed.
		Turn on the interrupt for this particular event.
		Change the state of the active task to AWAITING_EVT.
		Push the task on the interrupt blocked queues.
		Signal no error.

	For this kernel, user tasks can only wait on TIMER1 or TIMER2. This will cause
	the task to wait until a timer interrupt has occurred. 

	The interrupt blocked queues are stored as a single array of queues within the 
	TD Manager. The interrupt type (0 -> 31) is used as an index into the array 
	pointing to the head of each FIFO queue. If no task has called AwaitEvent() for
	an interrupt type, that queue has a null (0) value. We recognize that we will
	probably not turn on all 32 interrupt types and there may be some wastedspace
	here. However, we designed our kernel to be as flexible as possible with as 
	little rewriting of code in the future.
	
	Clock Server
	============
	The clock server is a user task that keeps track of the current time since 
	the kernel was started. It operates much like the name server and rock,
	paper, scissors server. Here is the pseudo code:

		Initialize the server by:
			Registering with the Name Server.
			Creating a helper Notifer task.
			Clearing the buffer of sleeping user tasks.

		FOREVER {
			Receive a query from another user task.

			If the query was Delay (ticks),
				Put the user task to sleep for at least ticks amount of time.
			If the query was DelayUntil (ticks),
				Put the user task to sleep until the current time is ticks.
			If the query was Time(),
				Return the current time to the user task.
			If the query was Notify(),
				Record the current time.
				Wake up any user tasks that should be woken up by Reply().
			If you received another query,
				Error!
		}

	The ClockServer mainly consists of a single queue of Sleeper structs,
	where Sleeper is of the form:
		TID tid;
		int endTime;

		Sleeper *nextSleepingUserTask;
		Sleeper *previousSleepingUserTask;

	This queue is a circular, doubly-linked list. 

	Delay
	=====

	Time
	====

	DelayUntil
	==========

	Clock Notifier
	==============


	User Tasks for Kernel 3
	==========================
	Since the assignment only asked for a description of the changes to the
	kernel, we will not include a description of the user tasks. The
	code is heavily documented and easy to read, if needed. Or, we will be happy
	to provide written details.

Question 3
==========
	All source code is located in: /u8/becmacdonald/cs452/a3/handin.

	Here are the md5 hashes for each file:

	
Question 4
==========
	Here is a listing of all submitted files:

	arch/switch.c              include/td.h
	arch/switch.S              include/ts7200.h
	documentation/k1.txt       lib/libbwio.a
	documentation/k2.out       lib/libclock.a
	documentation/k2.txt       lib/libdebug.a
	documentation/k3.txt       lib/libmath.a
	documentation/syscall.txt  lib/libstring.a
	driver/drivers.c           main/main.c
	include/bwio.h             main/orex.ld
	include/clock.h            main/syscalls.c
	include/clockserver.h      main/td.c
	include/debug.h            server/clockserver.c
	include/drivers.h          server/nameserver.c
	include/error.h            src/bwio.c
	include/gameplayer.h       src/clock.c
	include/gameserver.h       src/debug.c
	include/globals.h          src/Makefile
	include/math.h             src/math.c
	include/nameserver.h       src/string.c
	include/requests.h         task/gameplayer.c
	include/shell.h            task/gameserver.c
	include/string.h           task/requests.c
	include/switch.h           task/shell.c
	include/syscalls.h         task/task.c
	include/task.h



	Note: Extra compilation files may be included in the directories (.o, .s etc).

Question 5
==========

	Output and an explanation
