												becmacdo	Barbara Macdonald
												dgoc 		Daniel Goc

 	     __  __                                ___          __     
		/\ \/\ \                              /\_ \       /'__`\   
		\ \ \/'/'     __   _ __    ___      __\//\ \     /\_\L\ \  
		 \ \ , <    /'__`\/\`'__\/' _ `\  /'__`\\ \ \    \/_/_\_<_ 
		  \ \ \\`\ /\  __/\ \ \/ /\ \/\ \/\  __/ \_\ \_    /\ \L\ \
		   \ \_\ \_\ \____\\ \_\ \ \_\ \_\ \____\/\____\   \ \____/
		    \/_/\/_/\/____/ \/_/  \/_/\/_/\/____/\/____/    \/___/ 

Question 1
==========
	The executable is located at: /u8/becmacdonald/cs452/a3/handin/main/main.elf.

	To make the kernel, execute the following from the root directory:
	cd src/
	make clean && make all && make copy
	cd ..
	make clean && make all
	cp main/main.elf /u/cs452/tftpboot/ARM/becmacdo_a3.elf

	To load the program, type 'load ARM/becmacdo_a3.elf' at the command prompt.

	Finally, to operate the program, type 'go' at the RedBoot command prompt.

Question 2 
==========
	
	Weaknesses in Previous Kernel That We Fixed
	===========================================
	context switch
	td


	TD and TD Manager
	=================
	We made a few changes to our task descriptor (TD) struct and manager (TDM).
	We added a new TD state AWAITING_EVT to indicate that a task is blocked and
	waiting for a particular event. Tasks with this state will not be put on a 
	ready queue or scheduled to be active until the event has occurred.

	We also changed the name of our task descriptor manager. It used to be
	called PQ since it just held priority queue operations for the ready queue.
	Now that it has device drive information, the ready queues and the 
	await event queues, we've changed the name to TDM (which stands for TD Manager).

	Context Switch
	==============
	
	
	Interrupt Handling
	==================


	Device Drivers
	==============
	Each time a task wishes to use an interrupt, it must install a driver so that
	the kernel knows how to handle the interrupt. We did this so that the kernel
	would be portable and doesn't need to know about how to directly talk to the
	hardware.

	The drivers will usually handle turning off the interrupt that just triggered,
	reading the data and clearing buffers, etc. Basically, the driver will handle
	the interrupt once it has been triggered.
	
	One driver should be written per interrupt type. For this assignment, we are 
	only using the timers, so only a timer1Driver and tiemr2Driver were implemented.
	In future assignments, it will be very easy to implement other drivers. 
	Here is the pseudo code for the timer 1 and 2 drivers:
		Clear the timer interrupt.
		Return an empty buffer and NO_ERROR.
	
	A user task that will eventually call AwaitEvent() must first call 
	InstallDriver(). This is another system call that we have implemented. The
	function takes an interrupt type and a pointer to the corresponding driver
	function. This function is stored in the TD mananger in an array indexed by 
	the interrupt type it handles. The TD manager has 1 entry for every interrupt
	type (0->31).


	Await Event
	===========
	AwaitEvent() can be called by a user task to block the task until a particular 
	event has occurred. Since this is a system call, the handler for AwaitEvent()
	calls swi with the corresponding code (9) for this type of system call as a 
	single argument.
	
	Here is the pseudo code for kernel code of awaitEvent():
		Ensure that the arguments are correct.
			Event Id is valid.
			The driver for this event id has been installed.
		Turn on the interrupt for this particular event.
		Change the state of the active task to AWAITING_EVT.
		Push the task on the interrupt blocked queues.
		Signal no error.

	For this kernel, user tasks can only wait on TIMER1 or TIMER2. This will cause
	the task to wait until a timer interrupt has occurred. 

	The interrupt blocked queues are stored as a single array of queues within the 
	TD Manager. The interrupt type (0 -> 31) is used as an index into the array 
	pointing to the head of each FIFO queue. If no task has called AwaitEvent() for
	an interrupt type, that queue has a null (0) value. We recognize that we will
	probably not turn on all 32 interrupt types and there may be some wastedspace
	here. However, we designed our kernel to be as flexible as possible with as 
	little rewriting of code in the future.
	

	Clock Server
	============
	The clock server is a user task that keeps track of the current time since 
	the kernel was started. It operates much like the name server and rock,
	paper, scissors server. Here is the pseudo code:

		Initialize the server by:
			Registering with the Name Server.
			Creating a helper Notifer task.
			Clearing the buffer of sleeping user tasks.

		FOREVER {
			Receive a query from another user task.

			If the query was Delay (ticks),
				Put the user task to sleep for at least ticks amount of time.
			If the query was DelayUntil (ticks),
				Put the user task to sleep until the current time is ticks.
			If the query was Time(),
				Return the current time to the user task.
			If the query was Notify(),
				Record the current time.
				Wake up any user tasks that should be woken up by Reply().
			If you received another query,
				Error!
		}

	The ClockServer mainly consists of a single queue of Sleeper structs,
	where Sleeper is of the form:
		TID tid;
		int endTime;

		Sleeper *nextSleepingUserTask;
		Sleeper *previousSleepingUserTask;

	This queue is a circular, doubly-linked list. 

	Delay
	=====
	Delay() can be called by a user task to cause it to wait for a given amount
	of ticks. Here is the pseudocode:

		Grab an unused sleeper struct.
		Store the tid in the sleeper struct.
		Compute the end time by adding the current time to the ticks.
		Store the endTime in the sleeper struct.
		Insert the sleeper struct into the queue of sleepers in sorted order. 

	Note that the insert places the new sleeper in the queue in sorted order.
	It is not a FIFO queue! The sleepers are organized by endTime with the soonest
	end time closest as the head of the queue.

	DelayUntil
	==========
	DelayUntil() can be called by a user task to delay until the given end time.
	Here is the pseudo code:

		Grab an unused sleeper struct.
		Store the tid in the sleeper struct.
		Store the endTime in the sleeper struct.
		Insert the sleeper struct into the queue of sleepers in sorted order. 
	
	DelayUntil() and Delay() are very similar in functionality.

	Time
	====
	A user task can query the clock server for the current time by calling Time().
	This function will return the current time in ticks since the clock server
	started. To convert the raw CPU ticks to 50ms ticks, we grab the current time
	from a timer that is running at 2000Hz and divide it by 100.
	
	Clock Notifier
	==============
	When the ClockServer initializes, it spawns a working task called the Notifier.
	The ClockServer operates by calling Receive() and blocking until it is passed a 
	message from either another user task or the notifier. Since the ClockServer
	needs to keep track of the current time, we need to make sure it doesn't block
	for more than 1 tick. Hence, we see the need to have a notifier task.

	It is the notifier that listens for the TIMER1 interrupts and acts 
	accordingly. Here is the pseudo code for the notifier:
		Initialize the hardware and notifier.
		FOREVER {
			AwaitEvent ( Timer Interrupt );
			Check for errors during await.
			Send a message to the ClockServer to wake it up.
			Check for send errors.
		}

	Every 50 ms, a hardware interrupt is triggered from TIMER1. The notifier is 
	asleep waiting for this interrupt to occur. When it does, the notifier is 
	woken up and sends a message to the ClockServer to wake it up if is blocked 
	on Receive(). The notifier then awaits the next hardware interrupt.

	Right now, the notifier is specific to helping the ClockServer. It will be
	made more generic for future kernel assignments so that any task can spawn
	a notifier task.

	The priority of a notifier task is sufficiently important. It must be able to
	catch an interrupt as soon as it occurs and handle it appropriately. Hence,
	the notifier is made at priority 1, making it the second highest priority task
	behind the first user task for Kernel 3. Once this first task exits, the
	notifier has the highest priority and will always run if an interrupt has
	occurred. The Name and Clock servers are created with priority 2.


	Shell
	=====
	We decided to reuse code from assignment 0 to implement a shell/command prompt
	for this assignment. This shell lets us easily run the k1, k2, and k3 user
	tasks from the command line. When we are changing the context switch code,
	it is extremely useful to re-run the first kernel assignments to ensure they
	are still running.

	The shell is technically the first user task and can be used to initialize 
	servers and the state of the kernel. It is created with the lowest priority 
	possible and will only run when there are no higher priority tasks on the 
	ready queues.

	Type 'h' at the command prompt to get a list of valid commands. Nothing happens
	for invalid commands. 


	User Tasks for Kernel 3
	==========================
	Since the assignment only asked for a description of the changes to the
	kernel, we will not include a description of the user tasks. The
	code is heavily documented and easy to read, if needed. Or, we will be happy
	to provide written details, if required.

Question 3
==========
	All source code is located in: /u8/becmacdonald/cs452/a3/handin.

	Here are the md5 hashes for each file:

	1bbdde0f9272ce27b26219b36a56b28e  ./arch/switch.S
	8a714a74e007435dfb4fdc1499cefdf6  ./arch/switch.c

	0995484f9e2710b57b3cc58924953e51  ./documentation/k2.out
	52964ac97d4144df7768e6d5f4dba159  ./documentation/syscall.txt
	fe969235a8cc5bac3991570200e58ae1  ./documentation/k1.txt
	c12e6a30a6f74cfe0ed6e0d7b42c9d28  ./documentation/k2.txt
	e661fa70dcc47cc6cae2ee8571cf1f19  ./documentation/k3.txt

	4dec653ff77c6c60245b50034e1cd2a8  ./driver/drivers.c

	b47ec772c9587d700caaf495ebc0cdd6  ./include/math.h
	8b8513f4d8acfc7c286791873724de02  ./include/error.h
	8edbd0d3c6f3b9a913ed70ba64b93929  ./include/clock.h
	8cbe0128c7a89ad94a7d5542a758d743  ./include/syscalls.h
	79420f3c0b2224c9731b40c7e2882138  ./include/ts7200.h
	284f5809b261c65bf4298f5707c6890e  ./include/bwio.h
	1f636a0caf7a3b085550e06e9bf4f204  ./include/gameserver.h
	7362b29957ddfbbb258d656689368acd  ./include/switch.h
	145507954bf66a4cc19fe0753a820940  ./include/task.h
	f12dba7c03ed2d309d83f0c603bdf00a  ./include/string.h
	20779ceb04fffabc5d97ba646d30bcf5  ./include/shell.h
	3e1dc5f50f86a983d38c232fa247bac4  ./include/td.h
	aa9eeaa5e108edefedbdfc9610abcea6  ./include/nameserver.h
	2646bd05f7a8791a4799f7ecc05cfb83  ./include/requests.h
	845aa0a01f752a1fb41cf2766293e48b  ./include/drivers.h
	2b98d4e1e0bd5603872c6139dbac0874  ./include/clockserver.h
	4cdafbed0b30d282fa12007097533e5a  ./include/globals.h
	ccf98888e8b4b6ad9b9cb429697942f4  ./include/gameplayer.h
	49d6b686a32e30509085d69fade0562d  ./include/debug.h

	a70af2931fa4a98a497be405d27b8641  ./main/main.c
	9ec86426ab6e6cb316ed575b049bea0c  ./main/td.c
	5ef12d7238e4be4ffe0bfcd1d4419e63  ./main/orex.ld
	6daab6fcb9f20a5abf535f1a087f7a98  ./main/syscalls.c

	2f0b2ebc09094503ec50a74229f98a6d  ./Makefile

	a4741f6aa92cc98a01c18cc3414a0107  ./server/clockserver.c
	b35e3488258bd1e32debc848c4aa6280  ./server/nameserver.c

	307f9f9d74c14f53c14e1bb805d18964  ./src/bwio.c
	408c442d786f9436b969b27b5d934cd7  ./src/debug.c
	97a527897e5be8082b52809db93aa68e  ./src/string.c
	f75fdbf20b0775f6572773da7b216a50  ./src/math.c
	9b56cb4928b99c9d2cdb435f0f0f66c0  ./src/clock.c
	1e207d4c06aadc16e7ca20b25f540924  ./src/Makefile

	2a680012f3698e3f29e0571a0926a49e  ./task/gameserver.c
	0620c3a4f1ba615a24f32ae60f781684  ./task/task.c
	67176ab15a6023cb97879874dcb0c3b3  ./task/gameplayer.c
	18952f38ccb0a1e6026e880ce9f58a85  ./task/shell.c
	9f457ee9157b6c11499cc9242fcafc48  ./task/requests.c

Question 4
==========
	Here is a listing of all submitted files:
	
	.:
	arch           driver   lib   Makefile  src      task
	documentation  include  main  server    syscall

	./arch:
	switch.c  switch.S

	./documentation:
	k1.txt  k2.out  k2.txt  k3.txt  syscall.txt

	./driver:
	drivers.c

	./include:
	bwio.h         drivers.h     globals.h     shell.h     task.h
	clock.h        error.h       math.h        string.h    td.h
	clockserver.h  gameplayer.h  nameserver.h  switch.h    ts7200.h
	debug.h        gameserver.h  requests.h    syscalls.h

	./lib:
	libbwio.a  libclock.a  libdebug.a  libmath.a  libstring.a

	./main:
	main.c  orex.ld  syscalls.c  td.c

	./server:
	clockserver.c  nameserver.c

	./src:
	bwio.c  clock.c  debug.c  Makefile  math.c  string.c

	./task:
	gameplayer.c  gameserver.c  requests.c  shell.c  task.c

	Note: Extra compilation files may be included in the directories (.o, .s etc).

Question 5
==========

	Output and an explanation
