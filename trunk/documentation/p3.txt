												becmacdo	Barbara Macdonald
												dgoc 		Daniel Goc
			________             ________           _____     ________
			___  __ \__________________(_)____________  /_    __|__  /
			__  /_/ /_  ___/  __ \____  /_  _ \  ___/  __/    ___/_ < 
			_  ____/_  /   / /_/ /___  / /  __/ /__ / /_      ____/ / 
			/_/     /_/    \____/___  /  \___/\___/ \__/      /____/  
								/___/                                

 ____ ____ ____ ____ ____ ____ ____ ____ _________ ____ 
||Q |||u |||e |||s |||t |||i |||o |||n |||       |||1 ||
||__|||__|||__|||__|||__|||__|||__|||__|||_______|||__||
|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/_______\|/__\|

	The executable is located at: /u8/becmacdonald/cs452/p3/handin/main/main.elf.

	To make the kernel, execute the following from the root directory:
	cd src/
	make clean && make all && make copy
	cd ..
	make clean && make all
	cp main/main.elf /u/cs452/tftpboot/ARM/becmacdo_p3.elf

	To load the program, type 'load ARM/becmacdo_p3.elf' at the command prompt.

	Finally, to operate the program, type 'go' at the RedBoot command prompt.
 ____ ____ ____ ____ ____ ____ ____ ____ _________ ____ 
||Q |||u |||e |||s |||t |||i |||o |||n |||       |||2 ||
||__|||__|||__|||__|||__|||__|||__|||__|||_______|||__||
|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/_______\|/__\|

	The following is a description of our train application.

	Goal
	====
	Since we handed in the project description, we have changed the goal of our project.
	We decided to write a neat Reservation Server and deadlock detection and recovery
	solution. Our goal was to create situations with 5 trains where at least 2 trains
	were blocking a single train from reaching its destination. The trapped train
	was supposed to cause the idle blocking trains to move out of its way, let it pass,
	and move them back into place. Optional objective: solve world hunger.

	We were also going to implement a neat method to have trains follow each other 
	as closely as possible without having collisions occur as the leading train slowed down
	and sped up. The following train's reservations were supposed to notice the speed
	changes and change its speed to match.

	Finally, we wanted to have at least 3 trains running around in inner loop crossing
	in the middle without collisions.

	We believe that our reservation and deadlock recovery systems would be able to solve
	all sorts of difficult problems automatically.

	As of 10:00pm before the due date, the trains are still colliding sometimes and the
	deadlock simulation system has not yet been tested. It works "in theory". Despite
	the massive amounts of man hours we have invested into this project, we believe that
	our goal was too ambitious to complete within the allotted time. We do believe that
	the system would be in a much better state if we had just 1 more week to complete it.
	But, that's life!

	Here is a description of the code we have implemented for this project. We've made
	special notes of the sections that do not work.
	
	Model
	=====
	We decided to use the model provided on the course webpage to store the track
	graph. We did this because the track data was already measured and stored in
	a useable format. 

		Model Data Structure
		====================
		Here are the structs we use to store the model:

		typedef enum {
			SWITCH_STRAIGHT = 0,
			SWITCH_CURVED = 1
		} SwitchDir;

		typedef struct {
			int dest;
			int distance;
		} Edge;

		typedef struct {
			Edge 		ahead[2]; // (curved, straight)
			Edge 		behind;
			SwitchDir set;
		} Switch;

		typedef struct {
			Edge ahead;
			Edge behind;
			Edge filler[1];
			char trig_forward, trig_back;
		} Sensor;

		typedef struct {
			Edge ahead;
			Edge filler[2];
		} Stop;

		typedef struct {
			enum {
				NODE_SWITCH = 3,
				NODE_SENSOR = 2,
				NODE_STOP = 1,
			} type;
			char name[NODE_NAME_LEN];
			int id, idx;
			union {
				Switch sw;
				Sensor se;
				Stop st;
				Edge edges[3];
			};
			int reserved, reserver;
			int x, y; // location (for ui)
		} Node;

		typedef struct {
			int 	num_nodes;
			Node 	nodes[MAX_NUM_NODES];
			int 	sensor_nodes[NUM_SENSORS];
		} TrackModel;

		This is essentially taken from the course webpage with a few minor adjustments:
			1. The names were changed to use camel case.
			2. Each Node now stores its index in the TrackModel's nodes array.
			3. Each node has a reserved flag. If the flag is 1, this node is reserved.
			   We also store the train id of the reserving train.
			4. The x and y co-ordinates for the UI have been altered to store
			   the actual x and y measurements of each landmark.

		Parse & Ownership
		=================
		The model data is hardcoded into the model.c file as a string. This string
		can be parsed with sscanf to build the model data structure at any time.
		Since the model is quite large and memory intensive, we've decided to only
		let the Track Server and Route Planner parse and store the model.

		We decided against parsing the model once and passing it as a message
		to each task since the model is large. We will pay the parse time cost
		during initialization when it doesn't really count.

		Therefore, only the Route Planner and Track Server parse the model.
	
		Since route planning needs to consider track reservations, the model structure
		is shared between the Reservation Server and the Route Planner. This is the
		only global variable we have.

		Data Accuracy
		=============
		We are accepting the data in the track files as being accurate. Cherry confirmed
		that she measured some of the distances in the previous term. The new measurement
		double check this and have acutally pointed outa few places where there was a small
		discrepancy.

		New Measurements
		================
		Our Reservation Server turns the track into a 2D map. Therefore, we needed
		accurate locations of each landmark. Daniel spent a long time measuring the
		exact location of the landmarks and entering them into the model data.
		See the section on Reservations below.

	Route Planner
	=============
	A train will query the Route Planner to determine its route. It is able to
	determine the shortest path between any two nodes, distance between any two
	nodes, make predictions about the next sensors along a path, determine which
	switches will need to be set and to which directions, determine if a train
	needs to turn around / reverse, and more.

		Route Planner Data Structure
		============================
		The Route Planner is a private struct of the following form:
			int 			 distances[num_nodes][num_nodes];
			int 			 paths    [num_nodes][num_nodes];
			TrackModel		*model;
			Reservations	*reservations;

		It stores the minimum distance between any two nodes, the shortest path between
		any two nodes, and a model of the track.

		Shortest Path Algorithm
		=======================
		To be able to determine the shortest distance between any two nodes in 
		O(1) time, we run Floyd-Warshall's All-Pairs Shortest Path algorithm
		once during initialization and store the results. Here is the algorithm:

		Let dists be the distances matrix.
		Let paths be the path parent's matrix.

		Initialize matrices:
			dists[i][j] = 0 		if i == j
						  cost(i,j) if i and j are neighbours
						  Infinity  otherwise
			path[i][j] = -1

		for ( k = 0; k < n; k ++ ) {
			for ( i = 0; i < n; i ++ ) {
				for ( j = 0; j < n; j ++ ) {
					if (dists[i][j] > dists[i][k] + dists[k][j]) {
						dists[i][j] = dists[i][k] + dists[k][j];

						paths[i][j] = k;
					}
				}
			}
		}

		This algorithm computes the shortest distance between any two nodes in
		the graph and stores them in a distances matrix. It runs in time O(n^3).

		The cost function returns the distance in mm between two consecutive,
		neighbouring nodes. Thus, our algorithm will find the shortest distance in mm
		between any two nodes. Note that if a train needs to reverse along this path, 
		it may take longer to reach the destination than if the train had taken a longer
		route (distance-wise) that required it to only drive straight. We decided 
		that we are fine with using the shortest distance to determine the shortest
		path.

		The shortest path from node i to node j can be recovered in the following
		manner:

		outputPath( path, i, j ) {
			if ( path[i][j] == -1 ) {
				Display node i.
			}
			else {
				outputPath(path, i, path[i][j]);
				outputPath(path, path[i][j], j);
			}
		}

		The function uses recursion to follow the links stored during Floyd-Warshall
		to determine the path. The depth of the recursion is at most O(length of path).

		At a quick glance of our code, you will notice that we have implemented
		Dijkstra's Algorithm to determine the shortest path between 2 nodes.

		When reservations are cancelled and we want to recompute the distances,
		we found that running Floyd-Warshall is fast enough for what we need.

		Also, this allows us to "cache" our results for free. A train can always
		make a call to the Route Planner to determine the distance to the 
		nearest sensor and we don't need to recompute anything. We simply use the
		results that we already have.

		Therefore, while we realize that Floyd-Warshall might be overkill and,
		theoretically, too slow, it has worked in all of our tests so far.

		Why Do We Use Floyd-Warshall?
		=============================
		Floyd-Warshall allows us to cache our shortest paths results. We only run this
		algorithm once and can compute distances and paths from those stored results
		very quickly. We choose to pay a larger cost up front to save time when the 
		trains are running.

		Even with the Reservation Server, having the shortest path between any two nodes
		will collapse the graph for any sections that are not reserved, speeding up
		a Dijkstra or any other algorithm we might use to compute the paths using the
		Reservation Server.

		Route Planner to Train API
		==========================
		Currently, only the command prompt (shell) and trains talk to the Route Planner.
		Since the shell is specialized for testing, we've created special handlers
		for shell messages.

		When the train talks to the Route Planner, it communicates using sensor ids.
		Each sensor has a unique id within the sensor_nodes array of the model. We
		can use this id to determine the location of the train and direction it is
		going.

		When the Route Planner talks to the train, it sends sensor ids as predictions,
		distances in mm to particular landmarks, and switch settings/directions. 

		The train does not know anything about the model. We felt that the train
		should not need to know about nodes or need to parse the model for it to
		drive. We consider our train to be driven by either a blind engineer or one
		without a map. The Route Planner simply tells the train a distance to travel,
		direction, and switch settings. Thus, the train can focus on calibration
		instead of complex details about nodes and making sure it is travelling along
		a set path.

		Shortest Distance
		=================
		To get the shortest distance between any two nodes, we simply look up the
		corresponding entry in the distances matrix and return it to the train.

		Shortest Path
		=============
		To computer the shortest distance between any two nodes, we recurse on the
		path to build a list of landmarks. The list and length of the list are
		returned.

		Turn Around
		===========
		Since sensors give a direction and the train tells the Route Planner when 
		it triggers a sensor, we can easily tell if the train needs to reverse.

		Switch Settings
		===============
		Given a desired path and the last hit sensor, it is easy to determine the next 
		few switches a train will encounter and the direction they need to be set.
		When the Route Planner tells the train it has a valid path, it also returns
		some switch settings.
		
		SwitchSettings is a struct of the following form:
			int distanceToSwitch;
			int switchId;
			SwitchDirection dir;

		The train will receive a list of these settings and can flip switches 
		immediately before it needs to. Thus, when more trains are on the track, they
		will not interfere when switching switches.

		Right now, the train will flip switches that are not near it. This will change
		as we have more trains running on the track.

		If we had more time, we would have ensured that a switch is set in the correct
		direction regardless of the direction we are travelling over it. This way we
		are not relying on the spring property of the switches.

		Predictions
		===========
		Given a desired path and the last hit sensor, the Route Planner is able to 
		predict which sensors the train should hit next.

		If the train is facing forward, we follow the path in the desired direction
		and build a list of the first sensors it could hit. If the path reaches a switch,
		we follow in both directions in case the switch is not set correctly.

		If the train is facing backward, we tack on a list of all sensors it is facing
		in case it does not turn around correctly. This way we make a prediction for ANY
		route the train could take. If a sensor is hit and it is not a member of this list,
		we disregard the trigger since it is not possible for this train to have triggered 
		it.

		These predictions are given to the train. The train bundles the sensors and an 
		estimated trigger time range to send to the Detective. The Detective handles the
		trigger from there.

		In addition to determining all of the next sensors we could possibly hit,
		we now build a list of node predictions. This list includes every node
		a train will pass until it reaches a sensor. These predictions include
		each node a train could pass, independent of switch state or train direction.

	Detective
	=========
	The detective handles polling and allows trains to wait for a set of sensors to
	trigger. There is a expire time associated with each such request and if the request 
	expires, the train is notified and expected to recover.

		Notifiers
		=========
		The detective spawns two helper tasks - a polling task that tries to poll the 
		train box as often as possible, and a watchdog that makes sure the poller does not
		time out. Having an extra task for the watchdog allows our project to be really
		robust, even against such events as temporarily severing the train box connection.
		
		Any time the polling task returns its data (more than 1 sensor can be returned)
		we go through it and match against any outstanding requests. The poller notifier was
		originally a part of the track server, but to improve latency, we decided it should
		report directly to the detective.

		After getting a watchdog notify, we check for requests that have expired and reply 
		to them.

		WATCH_FOR
		=========
		This is the most useful request (from the train's POV) of the detective. It allows 
		the train to only wait on a specific set of sensor triggers, disregarding erroneous
		sensor data. Provided the train can predict the potential trigger windows accurately
		one would have to hit the right sensors within a fraction of a second to confuse 
		the train.
		
		When a WATCH_FOR request comes in, it is checked against the history of the last 
		time each sensor was hit. If a match occurs (in the past), the request is 
		answered immediately. This is handy for times when we have just passed over 
		a sensor.

		GET_STRAY
		=========
		In the event WATCH_FOR fails, the trains can resort to GET_STRAY. 
		This request will return the next (unmatched by WATCH_FOR) event. This way the train
		the train will disregard sensors triggered by other trains, for later assignments.

****TODO****
	The detective group of tasks is not much different from the last code. There is still
	one main server task, one poller task and a watchdog task. The few changes that were
	made are: 

	GET_STRAY and WATCH_FOR will overwrite any previous requests by a train. This is 
	unlike before where a train had to wait for a request to return. Also these calls 
	are non-blocking now, with the detective doing an explicit Send() to the train when 
	the request is handled. We've made this change because the train task is now a server.


	Also, we increased the grace period on the watchdog to 5 seconds, as sometimes the
	poll takes a bit longer to respond - especially when sending in other commands.
	The reason for this change is that resetting it too early might mean we discard useful
	sensor data.

		The detective also keeps a buffer of unaccounted for sensor triggers, but they are
		not used at this time.
	
	Track Server
	============
	The track server is largely unchanged from the K4 code, with the exception of the
	polling task now talking directly to the detective, and the detective passing on the
	values to the track server itself. We also added extra error checking and printing 
	through the UI task.

	Train
	=====
	The train is, by far, our most complex task. It has an exhaustive calibration system and
	lots of measured hardcoded values to estimate the train's location within 2cm.

** TODO ** More preamble about our impressive train
		
		
		Speed Calibration
		=================
		The train keeps a buffer of the last 10 track section speeds and calculates the
		mean and standard deviation of this sample. Data is only added to the buffer
		when we know the train is not accelerating and decelerating due to the train mode.
		This gives us a base speed to use in our calculations for current speed.
		This approach is robust against the train losing speed over time and does not 
		require hardcoded speed profiles per train. It also has the advantage of not having
		to figure these out ahead of time as this time-costly, at the expense of little extra
		calibration time at each run.
			
		The goal of calibration is to be able to track the train and correctly
		estimate its speed and distance within a small standard deviation of
		error.

		Thus, we run the train around the large loop of the track 2 times and 
		gather data to make these estimations. While estimating, we calculate
		the standard deviation of the estimations. To do this, we keep an array
		of the last 10 recorded speeds (as in P1) and calculate the standard
		deviation of this sample. We only add a speed to the buffer if the train 
		has not changed speed over the last sector to prevent contamination of data.
		This speed calibration remains enabled over the course of the run, 
		meaning it will adjust for the train slowing down with wear.

		The calibrator task moves the train to D9 and then E11 so that we 
		force a direction for it to travel around the loop.

		From E11, the calibrator tells the train to travel around the loop
		without changing speed until we have run around 3 times. After this
		third time, the train stops once it hits E11. It will usually travel
		much farther before actually stopping.

		At the shell, this actual stopping distance is manually entered into the
		train so that we can calibrate the hardcoded stopping distances.

		After this, the calibration task Exits.

		The neat thing about our calibration mode is that it is also a form of automated testing.
		As the train is travelling, it is calculating shortest routes via the Route Planner and 
		reserving and canceling sections of track. If any part of the system is broken, we can
		tell immediately during calibration.

		Stopping Distances
		==================

**** TODO ****
		
		During calibration, a manual stopping distance for the calibration speed
		is stored in the train.

		When determining which speed to travel at, we consider the stopping distance.
		If we have a long way to go, the train can speed up. The closer a train gets
		to the desired distance, the slower it should travel. 

		We currently have some stopping distances hardcoded into the train task.
		As trains are dropped, used more, oiled, etc, their stopping distances 
		change. To get around this, we can slightly alter the hardcoded stopping
		distances given the measured one as follows:

			stopDist = Hardcoded distance for the current speed.

			stopDist *= Measured stop distance for default speed.
			stopDist /= Hardcoded stop distance for default speed.

		We do it in this manner since it will avoid floating point calculations.
		A similar approach is used for all speed calculations - careful ordering of
		division and multiplication, coupled with normalizing the data at particular 
		times.

		Position Update
		===============
		When the detective gets a sensor that a train predicted, it tells the 
		train in the form of a position update. At that current point in time,
		the train knows exactly where it is and its direction.

		At this point we do the following:
			Reply to the detective.
			Ask for a new route given the new start location.
				If there is no path,
					Stop driving.
					Wake up the Route Watcher.
			If the train is facing backwards,
				Reverse.
			Adjust your speed given the new distance until stopping.
			If the distance until stopping is not 0,
				Flips the switches you need.
				Tell the Detective about the predicted nodes.
	
		Locating the train
		==================
		Whenever the train loses its position, it calls the locate subroutine. 
		Using a slow speed setting, that is unlikely to damage the train we do the following:

			timeout = 1 sec
			FOREVER {
				sensor = get_stray_sensor( timeout )
				
			  if( isValid( sensor ) ) break;
				train_reverse;
				timeout *= 2;
			}

		Since the timeout doubles every time, this is guaranteed to return the train location
		eventually assuming the train is actually moving.

		This subroutine is called at the beginning of train init to locate the train, 
		any time the usual sensor prediction goes horribly awry.

		Helper Tasks
		============
		The train currently has 3 helper tasks: 1 Heart, 1 Calibrator, 1 Route Watcher.
		These are all notifier tasks so their priorities' are all one higher than 
		that of the train.

			Heart
			=====
			The heart is a timer task that delays for a set period of time and Sends
			to the train. Upon the wake up, a train can update its location on the 
			track in between sensors.

			Hence, we can estimate the train's location anywhere on the track within
			the train's standard deviation worth of error. Assuming normal distribution
			this will predict the sensor hit correctly 99% of the time.
			(See Standard Deviation below).

			Route Watcher
			============
			This task has already been briefly explained in the Route Planner above.
			It is only woken up when a train cannot create any valid path. After
			Delaying for a set time, it Sends to the train to wake it up and try
			to plan a new route. If the blocking train has moved and made new
			reservations, then this train will be free to plan a route.
	
		Route Planning
		==============
		In order to keep the train task simple and focused on driving at the correct
		speed, the train does not know anything about the landmarks on the track.

		When the Route Planner returns, it simply gives the train a distance
		until it needs to stop, sensor predictions and switch settings. 
		While this is more complicated to handle within the train, it makes the 
		navigation code simple.

		Prediction
		==========
		When the Route Planner returns, a list of all nodes the train could possibly
		hit is returned. These predictions are forwarded on to the Detective with
		an estimated time window for hitting them.

		Reservations
		============
		A train calls the Reservation Server every 200ms to update its reservation
		and determine a safe distance that it can travel within. See below for
		implementation details.

	Reservation System
	==================
	For our final project, we decided to try a neat Reservation Server idea. We have
	converted the train track into a 2D point set and reserve points along the track
	as a train reservation. If these rectangular sections ever intersect, then
	a train collision can occur and the trains should slow down.

		2D Map
		======
		As mentioned above, Daniel has measured all of the landmarks on both tracks
		and entered the data into our model information. When our model is parsed,
		we know the exact location of each landmark in 2D space. 

		It is interesting to note that the straight-line point distances and the 
		distances between two neighbouring nodes do not differ by more than 7cm.
		The 7cm difference is noticed on curved sections of the track. For all other
		neighbouring edge distances, the straight-line distance does not differ from
		it by more than 2cm.
		
		Reservation Updates
		===================
		Reservations are updated every 200ms or every 11mm approximately for maximum
		accuracy. Since a train estimates its location every 200ms, it makes sense
		to update its reservations at this point as well.

		Train Representation
		====================
		A train on the track is represented by a series of rectangles. The minimum
		length of track we reserve varies based on a few different conditions.

		1. If a train has stopped, we reserve 1 train length worth of track on either
		side of where we estimate the train to be. Since our stopping distance
		relies on a estimation of where the train is, 2*train length is the minimum
		we can reserve to ensure that no train will collide with a stopped train.

		2. If a train is moving, we first reserve a bubble around the train and then
		try to reserve its stopping distance ahead of it.
		When trying to make a reservation, we pass in the total distance
		a train wants to go, stopping distance at the current speed, last triggered 
		sensor, and distance past the last sensor. 

		Using this stopping distance, the Reservation Server builds rectangles from
		the last triggered sensor forward until the end of the stopping distance.

		If a stopping distance is greater than the edge distance between 2 nodes,
		we build a rectangle from node to node and build another rectangle for the 
		remaining distance.

		If a remaining distance falls between 2 nodes, we grow a rectangle to
		the maximum size it can be using a binary search between nodes.

		It is important to note that the rectangles represent straight lines between 
		any two neighbouring nodes. Hence, it is possible for a rectangle length to be 
		less than the actual distance between 2 nodes. This is not a problem.

		When rectangles are made from node to node, both nodes are reserved so that
		the Route Planner can find routes around them. Otherwise, just the starting
		node is reserved.

		If a train is heading towards a switch, both routes will become reserved just 
		in case the switch is not flipped in time and the train heads down the 
		incorrect route.
		
		Train Intersections
		===================
		When a train tries to make a reservation, it passes in the stopping distance
		for its current speed. Using this, we grow rectangles forward until we've
		exhausted the stopping distance. If a rectangle intersects with another one,
		we say that trains can collide at that point.

		Hence, during the reservation process, we grow rectangles as far as we can 
		before intersecting with another rectangle. If an intersection occurs along
		the path, the Reservation Server will reserve up to just before the 
		intersecting area and return the safe distance that the train can travel.

		Using this distance, the train will adjust its speed until its stopping distance
		is within the range. If the train cannot stop in time, a collision will 
		probably occur. In this case, we cause the train to stop immediately and
		hope for the best.

		Geometry Class
		==============
		To map the track and trains and know when collisions have occurred, we have
		implemented an entire 2D geometry class with vectors, single points and 
		rectangles. 

		Since we are updating reservations and checking for collisions frequently, 
		we needed to ensure that these operations are fast. Efficient 2D rectangle 
		intersection code was found online and it used in 2D video games. 

		So, we know that two objects do not intersect if we can find a line that
		separates them. Using this fact, we take each edge of a rectangle, A, and
		verify that every point on the other rectangle, B, is on a different side
		than the remaining points of A.

		Rounding Errors and Accuracy
		============================
		Since the geometry class doesn't use floating point numbers, error is introduced
		as we are building the rectangles. We've decided to have an error margin of 2cm.

		The error is acceptable because we are only estimating the location of the train
		and this is not guaranteed to be perfectly accurate.
		Our error margin for the train location is usually 2cm after a full calibration.
		
		Data Structures
		===============
		The Reservation Server is a struct of the following form:
		typedef struct {
			TrackModel	*model;
			TrainRes 	 entries  [NUM_TRAINS];
			TID			 courierTid;
		} Reservation;

		It stores a pointer to the track model that is shared with the Route Planner. 
		
		Each train has a reservation entry of the following form:
		
		typedef struct {
			int 		trainId;			// Train identifier
			int			trainTid;			// Tid for this train

			bool		idle;				// 1 if this train is idle. 0, otherwise.

			int 		rectLen;			// Number of rectangles
			Rectangle  	rects[NUM_RECTS];	// TrainRes rectangles

			int 		idxsLen;			// Number of reserved node idxs
			int			idxs[NUM_IDXS];		// Reserved Node / Edge indexes
		} TrainRes;

		The data structure is fairly self-explanatory.

		Why a 2D Point Map? 
		===================
		We noticed that there are sections of the track near switches when two 
		trains can come very close and graze each other. It made sense for us to block
		off 2-dimensional areas instead of just blocking off 1-dimensional nodes. 

		We also wanted to try this idea as a proof of concept. As far as we know, this is the
		first time a group has decided to create a 2D Reservation Server and wanted to 
		see how feasible it is. We believe it is just as efficient as other methods
		and can solve special boundary cases automatically, without the need for 
		any special cases.

		Neat/Useful Things
		===================
		Here is a list of useful and neat things about our Reservation Server:

		- Using our rectangle growing, trains are given the maximum distance they
		wish to travel, while considering other reservations.
		
		- Trains now know their safe distance and have a section of track that
		they own. They only flip switches within this safe distance. This way we can
		ensure that multiple trains do not interfere with each other.
		
		- We only reserve a train length behind the train so that another train
		does not sneak up behind it and collide.
		
		- As mentioned above, collisions near switches are eliminated since we create
		straight-line rectangles towards the switch.
		
		- A train can have as many rectangles as it needs.

		- During a track reservation, if a train cannot travel its full desired distance
		due to an idle blocking train, we pick a random destination for the blocking 
		train and send it there. We hope that by the time the moving train reaches
		the reserved section it is clear. After moving to the random destination, the
		blocking idle train will move back to its start location. This has not been tested.
		
		- We believe our reservation is optimal. A train only reserves as far as it wants
		to go and never any more. 

		Limitations
		===========
		As far as testing just the Reservation Server without the trains (analyzing the 
		rectangles built along the length of tracks and verifying the reserved nodes are
		correct), our Reservation Server is quite good. We can detect many boundary cases
		where straight trains will collide on curved sections of track without any 
		special cases. All of our manual test cases have been solved automatically.

		Unfortunately, as of 1:35am before this project is due, trains are still colliding.
		We believe this is a problem with the train driving since static testing of the 
		Reservation Server has passed all of the normal and boundary cases we could think up.
		Testing will continue until the code freeze at 9:00am to determine the source of the
		collisions.

	Deadlock Detection & Recovery
	===============================
	We have a fairly impressive deadlock detection and recovery strategy that is currently 
	untested. It uses train predictions to simulate moves into the future and determine
	a set of moves that will clear a train's path as effectively as possible.

	As of 1:35am the night before this project is due, no part of this system has been tested.
	It's quite unfortunate since we think it will be VERY neat to watch and will make the trains
	look very intelligent. We have spent most of our time over the past few days working on the
	train task and Reservation Server to ensure that they are both working as best as they can.
	Unfortunately, testing the coolest part of our project was pushed off to the back burner. 

	Obviously, since this system has not been tested, it is still in the simplistic early stages.
	We were hoping to add lots of complexity and special edge cases to make it as optimal as possible.
	There are many neat real-time AI problems that could be solved!

	If we were allowed to continue working on the train project after the take-home exam, it
	would be neat to see what our system could accomplish with some testing and finesse.

		Detection
		=========
		During a track reservation, the Reservation Server knows where each train is
		by its reservation data and where it wants to go. If a train is unable make 
		any moves, the Reservation Server knows this and returns a safe travelling distance of 
		0. We hope that the train will determine it cannot safely move and will 
		halt immediately. As of 1:45am, the trains are being un-cooperative.

		At this point, the train will delay for 500ms and try to make a reservation. 
		During this time, we hope that a blocking train will move out the way and allow 
		this train to make a valid track reservation and start moving.

		If a train stays blocked for 5 iterations, we consider it to be stuck. At this point,
		it tells the Reservation Server it is stuck and we start the deadlock recovery code.

		Recovery
		========
		To free a train, we create a simulation system and run a possible set of moves through
		it to find a solution simulation system is a local copy of
		the current Reservation Server using a local copy of the track model. We can alter
		these local copies as we wish and they will not affect our actual system. Also since
		these are copies, they will act in the same manner as the actual system. 
		
		First, we run Dijkstra to determine the shortest path from its current node to
		its destination. It does not consider reservations and simply makes the shortest path.
		This is the path that our simulation will attempt to clear.

		Then we enter a loop until there are no reservations along the entire path by any 
		train other than the trapped one. Here is what we do in the loop:

			For each reserved node:
			If the train reserving it is idle, store its reservation entry. 
			Since we delayed before starting the deadlock recovery code to allow the
			non-idle trains to move, we hope that each train along the path is idle.
			** With testing, we could have determined the optimal wait time.

			For each of these idle trains, we simulate moving them forward along a 
			straight path without flipping any switches. 

			Repeat until the path is clear.

		Once the path is clear, we have the destination sensor (node?) for each train 
		that is blocking the path. Then, we simply tell the idle trains to move to these 
		endpoints and allow the trapped train to travel along the now clear path.

		Once the trapped train has travelled the path, the other trains should find their
		ways back to their starting points. 

		Obviously, this is a very simplistic starting system. We had hoped it make it 
		much more robust and add many tweaks.

		Neat/Useful Things
		==================
		Here is a list of neat things pertaining to the deadlock system:

		- For the final demo, we had hoped to simulate a gridlock situation with a
		path of 4 blocking trains and move them all out of the way for 1 trapped train.

		- If this code was called often enough, we can run Floyd-Warshall once to compute all
		of the shortest paths and used this stored data instead of running Dijkstra for every 
		deadlock.
		
		Limitations
		===========
		Here is a list of limitations (other than those listed above):

		- Our Reservation Server does not look ahead as it is making a reservation and determine
		that there a deadlock could occur with a particular reservation. It would probably
		be smart to do this.

		- This simulation is not bounded in time. It will keep simulating the trains forward 
		until the path is clear and it no longer needs to move trains. We can foresee some
		situations where the loop will not end.

		- There are many time-expensive computations during a deadlock recovery. This code
		is definitely not O(1). 
		
		- As the Reservation Server is figuring out these simulated steps, other 
		non-trapped trains cannot make reservations.

	UI / Shell
	==========
	We have designed a unique user interface (UI) for this project. This UI shows the
	state of the turn-outs, last 4 triggered sensors, location of the train 
	(distance in mm from last sensor it hit), current time in ms, and the shell
	prompt. Much of this information is overlayed on a map of the track. There 
	are unique maps depending on the track that is loaded.

		UI Implementation
		=================
		The UI is a server. User tasks that wish to display information send 
		this info to the UI server. All output formatting is contained within the
		UI server. Here is the pseudo-code:

		Initialize:
			Get the track id from the shell.
			Parse the corresponding model.
			Clear the screen.
			Draw the map and other static information.
			Create the timer notifier.
			Register with the Name Server.
			Reply to the shell to let other tasks run.

		FOREVER {
			Receive from a user task.
			Reply to the user task immediately.

			switch( request type ) {
				case CLOCK:
					Display the current time.
				case TRACK_SERVER:
					Update a switch setting on the map.
				case DETECTIVE:
					Update the last triggered sensors.
				case TRAIN:
					Update the train's current location.
			}
		}

		The UI task is kept as simple as possible. It has quite a few functions
		that can send special escaped character sequences to the terminal.

		Layout
		======
		The track map prints at the top of the screen. The switch settings are
		displayed over the map.  The train location is displayed inside
		the left-most loop and the current time (in ms) is displayed in the
		right-most loop.

		The last triggered sensors, triggered by a train or a malicious TA, will
		display below the map. We will show the last 4 triggered sensors. 

		The shell prompt will display at the very bottom and can show 3 lines
		worth of scrolling data.

		Shell
		=====
		The shell does not print itself via the UI server for the following
		reasons:
			1. We've been using the shell since A0 so we know it works. The UI
			   is new code which may have bugs. Hence, the shell is more robust
			   and we can count on it to display properly.
			2. We need to be able to scroll to see error and debug data. The 
			   shell does this for free.
			3. We need to use the shell before the UI starts.

		The Shell is the only user task that will display text itself, other
		than the UI in our production code.

		Efficiency
		==========
		There are many calls to cprintf within the UI server. These calls could 
		be merged together to create more efficient output. 

		Advantages
		==========
		All of the formatting is stored within one simply user task. If we need to 
		change how a particular gadget is displayed, this will be very simple.

		Limitations
		===========
		Each element that is drawn to the screen needs to be sent via a message to
		the UI. This can be very costly time-wise.

	Neat Things
	===========
	We did some neat things for this assignment. Here's a brief discussion of
	some of them.

		Debug Code
		==========
		We have many asserts and debug print statements. This can create bloated code
		and is not desirable for production (demo) code. Hence, all of our debug code is
		placed within compiler macros and will be stripped out if we don't need it.

		Train Speed Data
		================
		Please see the attached spreadsheet data for all of the data we have collected
		about each of the trains. We have accurate stopping distances and times for
		almost all of the trains (Fraser brought in new ones the night before the demo).

		From this data, we have been able to predict acceleration, deceleration, and
		speed functions. We now use these in our code to predict the location of the train.

		Multi-Track Drifting
		====================
		Multi-track drifting occurs when the front and back wheels run on opposite
		parts of a track after going over a switch. This happens when a switch is changed
		while the train is on top of it.

		To prevent this, we create a buffer in front of the train and tell it to not
		flip switches if it is less than this distance away from the switch.

		Stopping Locations
		==================
		Since we tell the trains to travel for a set distance, we can have them park
		at any location on the track, not just at sensors.

		Track Measurements
		==================
		We measured the location of every single node on both tracks from an
		origin point. These measurements are stored in our model file and are used to 
		make the 2D map of the track. We would be happy to share these with the TAs
		and professor for future offerings of this course.

		Kernel
		======
		Since we started working on the project, we have not modified our kernel. Woot!

		Global / Static Variables
		=========================
		In order to reduce coupling, there are no global or static variables anywhere
		in our code, except for the sharing of the track model. Each task
		is completely self-contained.

		For the track model, it was more efficient to share the data than the pass the updated
		reservation data back and forth in a message.

		Optimization
		============
		We were the first group to figure out how to compile in optimized mode.
		Virtually all our code is compiled with 02 optimizations on, there is one
		little file with two tiny functions that never get called that is not 
		optimized to fool the compiler into loading function pointer properly.
		Inside the kernel, the volatile modifier is carefully used to ensure memory
		reads/writes do not get optimized away in places that they do not need to.
		Furthermore, our context switch assumes the number of registers saved by 
		the request call primitives. This has changed with the optimization on, 
		and the appropriate number had to be updated.

		The code speed increased by 2 - 3 times with O2 optimization on.
	
		We do not particularly feel like debugging gcc optimization bugs at this time
		and so we chose to use the stable O2 optimization instead of O3.

		Cache
		=====
		Both the data and instruction caches are on.
		
		Task Priorities
		===============
		We have designed a task priority hierarchy for this assignment. It works
		as follows:

		#define NUM_USER_PRIORITIES	10
		#define HW_SERVER_PRTY 		1
		#define NOTIFIER_PRTY 		HW_SERVER_PRTY - 1
		#define OTH_SERVER_PRTY		3
		#define OTH_NOTIFIER_PRTY	OTH_SERVER_PRTY - 1
		#define	IDLE_PRTY			NUM_USER_PRIORITIES - 1
		#define SHELL_PRTY			IDLE_PRTY - 1

		#define TRAIN_PRTY			5
		#define LOW_SERVER_PRTY		7

		We have 10 different priorities, ranging from 0 to 9, and they are
		assigned as follows:

		0 is used for hardware notifiers since we need to handle hardware interrupts
		as soon as they occur.
		1 is used for hardware servers.
		3 is used for other servers ( UI and track server ).
		2 is used for the notifiers of "other servers".
		5 is used for train tasks.
		7 is used for the only low priority server, the Route Planner.
		8 is used for the shell.
		9 is used for the idle task.

		Notifiers must always have a higher priority than the servers they are
		notifying.

		Commits
		=======
		As of 12:15am before the assignment is due, we are at 911 Subversion commits. 
		We're hoping to get to 1000 before the night ends, but this is probably unlikely.

		Line Count
		==========
		As of 2:30am before the assignment is due, we have 11439 lines of code in our repository.

	Limitations & Challenges
	========================
	There were many challenges we faced while implementing our train application, due to
	our design decisions.

		Distance System
		===============
		Our train still drives "blind". This means that the train does not know anything
		at all about the track. It is given distances to travel, predicted sensors and
		nodes, and switches to flip. It was our goal to make the train as simple as 
		possible so that it can focus on estimating its location and calibration.

		This ended up being very difficult to do. We now feel that the train should
		have more information to work with.

		Aggressive Reservation System
		=============================
		Our Reservation Server is very aggressive. We always try to make a reservation end
		as close as it can to the next train. If our train location estimations are
		slightly off, then train's can collide even though the reserved sections are 
		correct. In this case, it is probably a good idea to test the system thoroughly
		and add an error margin.

	Course Commentary
	=================
	Overall, we have both enjoyed the course. We've learned much about time management,
	dedication, motivation, and determination. These are all qualities that are very 
	important to learn, but are not usually taught in the classroom.

	We have also learned much about implementing real-time operating systems,
	programming in C, the frustrations of not having pre-made, well-tested libraries, 
	device drivers and low-level hardware controls, debugging and many more things.

	We both feel that we needed less time to implement the kernel and more time to
	implement the real-time train application at the end of the course. If we had a 
	few extra days, we believe we could have a fully working, impressive project.

 ____ ____ ____ ____ ____ ____ ____ ____ _________ ____ 
||Q |||u |||e |||s |||t |||i |||o |||n |||       |||3 ||
||__|||__|||__|||__|||__|||__|||__|||__|||_______|||__||
|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/_______\|/__\|

	Here are the md5 hashes for each file:

	6248d233ef4a0935c26cdefbc082ba0a  ./kern/syscalls.s
	ff334fdf2ea5232f8ff3e374b69e4245  ./kern/main.c
	4749098b4d898c025e156b3705bbb9b8  ./kern/td.c
	ebbda576e9a738b99f5384dbcb40348a  ./kern/orex.ld
	fb33d2c7b3ca4d3c7ce07c8e0638f32b  ./kern/syscalls.c
	715c0bca62843e796e19dafe7490813b  ./kern/syscalls.o
	c78c46961c1676ca9660b4d1d86856fd  ./kern/main.s
	7cfe72db9c3f68b5d58c5885f6698c8d  ./kern/main.o
	27cdfcf5fb2b0eb02cf07d2198c3dc8b  ./kern/td.s
	6f45ff20f0fc8dba150a43968468a0d5  ./kern/td.o
	1e8f49432fef07e525ec2f06c10e51c1  ./kern/main.map
	f90dbbef944616ea23abc91e4946e6c2  ./kern/main.elf

	4b9d6c583e486a9664371406f87dde3d  ./task/gameplayer.s
	5c79ef173674f2c84130aecda39abf67  ./task/gameserver.c
	6152327419cbef8af5e19ce843e1eca3  ./task/task.c
	43c84644f93f6e78930acf587f491930  ./task/gameplayer.c
	30213ee4935bb028318ecfa44bf92732  ./task/shell.c
	28c4a8ae3b1ba4cebdd897cf88b126a6  ./task/gameplayer.o
	cb2a9fea01f4061c369a2c84748d0bab  ./task/gameserver.s
	9def214b7db0242e26da04df08f4a253  ./task/gameserver.o
	4c93a0036e065def4249a79363c66ee5  ./task/shell.s
	11221852fcc59832a1af3888783abc0b  ./task/shell.o
	fd5fc50ff7f24001ed59b27189eccd05  ./task/task.s
	9caf7effc44088bbb4cfb2e723442c2f  ./task/task.o

	e190a73becbcbd7af79987ee8e51fd9f  ./include/servers.h
	fd1f7faece04ff0500d80c85a5018711  ./include/error.h
	02bc656dc25ba4af3b4a2b56f9c544df  ./include/math.h
	3827d6ac49fcd5962842b452c1b85aa6  ./include/trackserver.h
	5efc2b57900cdd08ee04372ad606edde  ./include/syscalls.h
	58e7ea88711ea3455cc9b65561e80c14  ./include/ts7200.h
	8146ed251b92ea06a95351da69340699  ./include/gameserver.h
	fb7609f4f9b67fa4c3c5f16b02330712  ./include/bwio.h
	419d45aabe06df9f1a1953679808be36  ./include/model.h
	7193db01edef139a56deb8c0a8e8b02d  ./include/reservation.h
	2f03b38f8c205f7f1a08d5b2cfdcb169  ./include/switch.h
	5696d925f014e68d7d052d9a209125e7  ./include/task.h
	67a9150395d1ba08a2061552601d24e6  ./include/string.h
	9a9b2e58b88b5412afefe439cac97326  ./include/td.h
	660e3c8c27ef66e7e03a7f49b26f4fae  ./include/shell.h
	6fa2c3d28864f6cd38ff3cea936c104b  ./include/buffer.h
	83d86af721808a22a092db9d3cbfdf7e  ./include/requests.h
	803190f8ad15f69ffd4750861676976d  ./include/train.h
	9312559f8df6a46f874cf4eadff47328  ./include/ui.h
	67e70e8647557c6d928f15eab1381a49  ./include/drivers.h
	a4737853ba1313ae28bd2577ae811839  ./include/routeplanner.h
	3f2c033376145f428dce09075c96cf08  ./include/globals.h
	88790ee55eb595666ec820418bc74378  ./include/fifo.h
	ccf98888e8b4b6ad9b9cb429697942f4  ./include/gameplayer.h
	3a3ce59eb4a90dbf61fcaeb129e47763  ./include/debug.h

	2b26d02a8c605a843ae2c7ba5ed6c649  ./lib/libbwio.a
	1fcf48eb025c1bc102927a7a490f7790  ./lib/libdebug.a
	49bedb25173b8198fd60427b9ccc061a  ./lib/libstring.a
	91c37a9aa39e444a63a4307b32ea499c  ./lib/libmath.a
	94925c9f601605cb0d8a2dfef8cde65e  ./lib/libbuffer.a

	ab439d208b8327bcd600ab87c9f68ef7  ./server/clockserver.s
	9a0e976c1f786d68753dce3562e882a8  ./server/clockserver.c
	5cf469b48fbafcc7b85993eb2a254fcb  ./server/nameserver.c
	a7ce6cd7ae1805395cade0bfd137a25c  ./server/serialio.c
	f9d78b0598ee83615856810ff0f3ed20  ./server/clockserver.o
	6170a5e0825f1776457fe7a143891d23  ./server/nameserver.s
	0b6b340c9ecc2542a46f536c5fe52977  ./server/nameserver.o
	0becf5a7ff0386e627a5e788b912f783  ./server/serialio.s
	959d985ae8ca55d1776d79fe80f06e2c  ./server/serialio.o

	afa37848f6d149701d45394b5eedc527  ./src/bwio.s
	ab667fc308f3a868abe305dde11d7589  ./src/bwio.c
	4042844222d0cd3740b18f99b1c824a5  ./src/fifo.c
	fe7345c32d27b7b615048b272de24c13  ./src/debug.c
	c2c533982b37adfd03467601f58e40fa  ./src/string.c
	f469bbdad899eab6fe91dec26ef08917  ./src/math.c
	c513e3f376cfb4ef77d1796bb48ccdef  ./src/buffer.c
	fa5e9c4e46d48e60b422286274aadeac  ./src/Makefile
	2b26d02a8c605a843ae2c7ba5ed6c649  ./src/bwio.a
	9f492b248467a5e363c930a3ab2daa79  ./src/debug.s
	1fcf48eb025c1bc102927a7a490f7790  ./src/debug.a
	9bf27ed1c518c975f9720edf0ef9fa33  ./src/string.s
	49bedb25173b8198fd60427b9ccc061a  ./src/string.a
	066fa617df90d5c0ad998c5668cf9580  ./src/math.s
	91c37a9aa39e444a63a4307b32ea499c  ./src/math.a
	782b832099da2dbe9956aaf2c30a5034  ./src/buffer.s
	94925c9f601605cb0d8a2dfef8cde65e  ./src/buffer.a

	3cc746d7e48569566ba91afcd64d1ade  ./documentation/p2.txt
	e0b45e2bb3becddd1a17646e462336a6  ./documentation/p3.txt
	0995484f9e2710b57b3cc58924953e51  ./documentation/k2.out
	52964ac97d4144df7768e6d5f4dba159  ./documentation/syscall.txt
	fe969235a8cc5bac3991570200e58ae1  ./documentation/k1.txt
	c12e6a30a6f74cfe0ed6e0d7b42c9d28  ./documentation/k2.txt
	9abe1c6037cfae6365900a5ba300df23  ./documentation/k3.txt
	f2c08a56da789e93f3595bd099122a65  ./documentation/k4.txt
	a1bd6b701571edfd0d7312fdb0bbf5a7  ./documentation/proposal.txt
	012de728eb811b638c338260d779391c  ./documentation/p1.txt

	b5f288fb854c3bc03fedb3d2b1ab37a8  ./arch/drivers.s
	af75127f35f286928b8e16153d07f7e7  ./arch/drivers.c
	29632b3f08e1713528c1145dab2f6388  ./arch/ep93xx.c
	751398e0370bcd05ee43cacb3ed33ee8  ./arch/switch.S
	8a714a74e007435dfb4fdc1499cefdf6  ./arch/switch.c
	8fb6754e34da4be7f442e9ada5eb310f  ./arch/requests.c
	08936ac97b4e596a0ba49b026339cb6b  ./arch/primitives.S
	b6adcaf7d0e8b696b91198511ae83676  ./arch/drivers.o
	e8c58ddb1eaf2e70e4563a0019c297d4  ./arch/requests.s
	75c4503d58806ca5b444235420083ee0  ./arch/requests.o
	aa5adcbc0ad30d8c3ba07f96d94fd055  ./arch/primitives.o
	b272bcab0f3c7818147d59a88ccc9c32  ./arch/switch.o
	bc371e93f3b392e22dc750e872eb0436  ./arch/ep93xx.s
	fbce450789f99afe66a2832ca484543d  ./arch/ep93xx.o

	f7ef95a7ed66fc45b8ce9d6087a0e7ac  ./train/detective.s
	efac1d2d7f02d26a3cac018f4d605d3c  ./train/routeplanner.c
	2458fbe11fc021c55928252da74cae37  ./train/detective2.c
	bdc37daaf06c33be966eeac287424859  ./train/model.c
	49d271eb4187f06a0323156efc40aa15  ./train/reservation.c
	d15b68801e9d3f2db4fc0b9b4359caef  ./train/trackserver.c
	a27f2bebe55cb79f5f150cd858fd48ca  ./train/detective.c
	7a9d7f85c5bd60f9d0761fff098ea13d  ./train/train.c
	03253f39ce656e150609d15131cbe6a5  ./train/ui.c
	72ef5a9fe16cee1a3dbf7ea552fd3c9e  ./train/detective.o
	4aa2dcef24b0ad9b62a53dd42827ffc9  ./train/model.s
	d5d75bcf25d72056264b82a021bbfde7  ./train/model.o
	f5c54158e65c81bb28b4a33fd3de3067  ./train/reservation.s
	6402808263a46b3416869b93fa4bc193  ./train/reservation.o
	6bd3cf2d7ff28b0c0c44c09ed4954776  ./train/routeplanner.s
	bad49d75de11a4f093ec3e51542d5ef8  ./train/routeplanner.o
	70b45cbe0660670e63bdb53e0f2473f0  ./train/trackserver.s
	981708d75660b9fce1756cad55d20f8f  ./train/trackserver.o
	df3c2a358a07f71195e1864073568d8c  ./train/train.s
	3254214a9e2f909f260578cb53640c47  ./train/train.o
	bb9d536e303d59c7d8fcfd64ec3d6a3e  ./train/ui.s
	29c1f333b7a01bb9a6dc6e9cae428ba0  ./train/ui.o
	24e8bc999835a26937df4e4d53725497  ./out
	de975f7952206ab06c7233a544c0106e  ./todo.txt
	b713e7fce8154121fdc176acd2a9986c  ./wishlist
	d74c7c793e55b9fc126c346cec6ff1fb  ./Makefile

 ____ ____ ____ ____ ____ ____ ____ ____ _________ ____ 
||Q |||u |||e |||s |||t |||i |||o |||n |||       |||4 ||
||__|||__|||__|||__|||__|||__|||__|||__|||_______|||__||
|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/_______\|/__\|
	
	Here are all of the files we are submitting:

	.:
	arch           include  lib       ot   server  task      train
	documentation  kern     Makefile  out  src     todo.txt  wishlist

	./arch:
	drivers.c  ep93xx.c  primitives.S  requests.c  switch.c  switch.S

	./documentation:
	k1.txt  k2.txt  k4.txt  p2.txt  proposal.txt
	k2.out  k3.txt  p1.txt  p3.txt  syscall.txt

	./include:
	buffer.h   fifo.h        model.h         shell.h     td.h
	bwio.h     gameplayer.h  requests.h      string.h    trackserver.h
	debug.h    gameserver.h  reservation.h   switch.h    train.h
	drivers.h  globals.h     routeplanner.h  syscalls.h  ts7200.h
	error.h    math.h        servers.h       task.h      ui.h

	./kern:
	main.c  orex.ld  syscalls.c  td.c

	./lib:
	libbuffer.a  libbwio.a  libdebug.a  libmath.a  libstring.a

	./server:
	clockserver.c  nameserver.c  serialio.c

	./src:
	buffer.c  bwio.c  debug.c  fifo.c  Makefile  math.c  string.c

	./task:
	gameplayer.c  gameserver.c  shell.c  svn-commit.tmp  task.c

	./train:
	detective2.c  model.c        routeplanner.c  train.c
	detective.c   reservation.c  trackserver.c   ui.c

	Note: Extra compilation files may be included in the directories (.o, .s etc).
