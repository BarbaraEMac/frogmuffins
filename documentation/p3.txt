												becmacdo	Barbara Macdonald
												dgoc 		Daniel Goc
			________             ________           _____     ________
			___  __ \__________________(_)____________  /_    __|__  /
			__  /_/ /_  ___/  __ \____  /_  _ \  ___/  __/    ___/_ < 
			_  ____/_  /   / /_/ /___  / /  __/ /__ / /_      ____/ / 
			/_/     /_/    \____/___  /  \___/\___/ \__/      /____/  
								/___/                                

 ____ ____ ____ ____ ____ ____ ____ ____ _________ ____ 
||Q |||u |||e |||s |||t |||i |||o |||n |||       |||1 ||
||__|||__|||__|||__|||__|||__|||__|||__|||_______|||__||
|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/_______\|/__\|

	The executable is located at: /u8/becmacdonald/cs452/p//handin/main/main.elf.

	To make the kernel, execute the following from the root directory:
	cd src/
	make clean && make all && make copy
	cd ..
	make clean && make all
	cp main/main.elf /u/cs452/tftpboot/ARM/becmacdo_p3.elf

	To load the program, type 'load ARM/becmacdo_p3.elf' at the command prompt.

	Finally, to operate the program, type 'go' at the RedBoot command prompt.
 ____ ____ ____ ____ ____ ____ ____ ____ _________ ____ 
||Q |||u |||e |||s |||t |||i |||o |||n |||       |||2 ||
||__|||__|||__|||__|||__|||__|||__|||__|||_______|||__||
|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/_______\|/__\|

	The following is a description of our train application.
	
	Model
	=====
	For the project we have extensively remeasured the tracks, particularly 
	the x and y coordinates which we use in our reservation system.

	For this assignment, we simply use the reserved flag in each node to set it
	as reserved or not. We have not modified our representation of the track for
	P2.

	Route Planner
	=============
	 We've made some minor modifications
	to our shortest distance calculator (Floyd-Warshall) to consider the extra
	distance required for a reverse in the middle of a path. 
	
		Sensor Predictions
		==================
		Since our sensor predictions worked for P1, we have not modified them for P2.
		We've simply added some Node Predictions.
	
		Node Predictions
		================
		In addition to determining all of the next sensors we could possibly hit,
		we now build a list of node predictions. This list includes every node
		a train will pass until it reaches a sensor. These predictions include
		each node a train could pass, independent of switch state or train direction.

		Floyd-Warshall
		==============
		At a quick glance of our code, you will notice that we have implemented
		Dijkstra's Algorithm to determine the shortest path between 2 nodes.

		When reservations are cancelled and we want to recompute the distances,
		we found that running Floyd-Warshall is fast enough for what we need.

		Also, this allows us to "cache" our results for free. A train can always
		make a call to the Route Planner to determine the distance to the 
		nearest sensor and we don't need to recompute anything. We simply use the
		results that we already have.

		Therefore, while we realize that Floyd-Warshall might be overkill and,
		theoretically, too slow, it has worked in all of our tests so far.
	
	Reservation System
	==================

		2D Map
		======

		Train Representation
		====================
		- reserve to stopping distance
		- updated every 11mm or so for maximum accuracy
		- when stopped, build a bubble around train of size train + error
		- how rectangles are built

		Train Intersections
		===================
		- rectangle intersections
		- grow rectangles as far as they can go (wthin 1cm)
		- lets trains travel as far as they possibly can

		Useful Things
		=============
		- reserve nodes within reservation distance
		- only flip switches if a train has them reserved
		- trains know they can drie within their safe distance
		- never reserve behind a train unless it is stopped
		- collions on switches are detected since we use straightline rectangles
		- train can have as many rectangles as it needs

	Deadlock Detection & Recovery
	===============================


		Detection
		=========
		- reservation system will return a safe distance of 0

		Recovery
		========
		- First, assume train is moving and will move out of the way
		- wait for 1000 ms for the train to move and try again
		- if not successful, check train status
		- if idle, move it
		- otherwise, wait more

		how does the train get moved?

		Limitations
		===========
		- cannot predict and prevent


	Detective
	=========
	The detective group of tasks is not much different from the last code. There is still
	one main server task, one poller task and a watchdog task. The few changes that were
	made are: 

	GET_STRAY and WATCH_FOR will overwrite any previous requests by a train. This is 
	unlike before where a train had to wait for a request to return. Also these calls 
	are non-blocking now, with the detective doing an explicit Send() to the train when 
	the request is handled. We've made this change because the train task is now a server.

	When a WATCH_FOR request comes in, it is checked against the history of the last 
	time each sensor was hit. If a match occurs (in the past), the request is 
	answered immediately. This is handy for times when we have just passed over 
	a sensor.

	Also, we increased the grace period on the watchdog to 5 seconds, as sometimes the
	poll takes a bit longer to respond - especially when sending in other commands.
	The reason for this change is that reseting it too early might mean we discard useful
	sensor data.

	Track Server
	============
	We have not modified how our project sends commands to the train controller.
	Therefore, the Track Server has not changed since the first project.

	Train
	=====
	Since the first iteration of our train was not working as smoothly as we would
	have liked, we have scrapped most of it and started again. The majority of the
	time spent on this assignment was spent on recoding this task.

		Server
		======
		Since the train has so many helper tasks, we've turned it into a server
		to simplify the code. Any Send call made by the train is guaranteed to be
		non-blocking. 

		Helper Tasks
		============
		The train currently has 3 helper tasks: 1 Heart, 1 Calibrator, 1 Route Watcher.
		These are all notifier tasks so their priorities' are all one higher than 
		that of the train.

			Heart
			=====
			The heart is a timer task that delays for a set period of time and Sends
			to the train. Upon the wake up, a train can update its location on the 
			track in between sensors.

			Hence, we can estimate the train's location anywhere on the track within
			the train's standard deviation worth of error. Assuming normal distribution
			this will predict the sensor hit correcly 99% of the time.
			(See Standard Deviation below).

			Calibration
			===========
			The goal of calibration is to be able to track the train and correctly
			estimate its speed and distance within a small standard deviation of
			error.

			Thus, we run the train around the large loop of the track 3 times and 
			gather data to make these estimations. While estimating, we calculate
			the standard deviation of the estimations. To do this we keep an array
			of the last 10 recorded speeds (as in P1) and calculate the standard
			deviation of this sample. We only add a speed to the buffer if the train 
			has not changed speed over the last sector to prevent contamination of data.
			This speed calibration remains enabled over the course of the run, 
			meaning it will adjust for the train slowing down with wear.

			The calibrator task moves the train to D9 and then E11 so that we 
			force a direction for it to travel around the loop.

			From E11, the calibrator tells the train to travel around the loop
			without changing speed until we have run around 3 times. After this
			third time, the train stops once it hits E11. It will usually travel
			much farther before actually stopping.

			At the shell, this actual stopping distance is manually entered into the
			train so that we can calibrate the hardcoded stopping distances.

			After this, the calibration tasks Exits.

			Route Watcher
			============
			This task has already been briefly explained in the Route Planner above.
			It is only woken up when a train cannot create any vaild path. After
			Delaying for a set time, it Sends to the train to wake it up and try
			to plan a new route. If the blocking train has moved and made new
			reservations, then this train will be free to plan a route.

		Stopping Distances
		==================
		During calibration, a manual stopping distance for the calibration speed
		is stored in the train.

		When determining which speed to travel at, we consider the stopping distance.
		If we have a long way to go, the train can speed up. The closer a train gets
		to the desired distance, the slower it should travel. 

		We currently have some stopping distances hardcoded into the train task.
		As trains are dropped, used more, oiled, etc, their stopping distances 
		change. To get around this, we can slightly alter the hardcoded stopping
		distances given the measured one as follows:

			stopDist = Hardcoded distance for the current speed.

			stopDist *= Measured stop distance for default speed.
			stopDist /= Hardcoded stop distance for default speed.

		We do it in this manner since it will avoid floating point calculations.
		A similar approach is used for all speed calculations - careful ordering of
		division and multiplication, coupled with normalizing the data at particular 
		times.

		Position Update
		===============
		When the detective gets a sensor that a train predicted, it tells the 
		train in the form of a postion update. At that current point in time,
		the train knows exactly where it is and its direction.

		At this point we do the following:
			Reply to the detective.
			Ask for a new route given the new start location.
				If there is no path,
					Stop driving.
					Wake up the Route Watcher.
			If the train is facing backwards,
				Reverse.
			Adjust your speed given the new distance until stopping.
			If the distance until stopping is not 0,
				Flips the switches you need.
				Tell the Detective about the predicted nodes.
	
		Route Planning
		==============
		In order to keep the train task simple and focussed on driving at the correct
		speed, the train does not know anything about the landmarks on the track.

		When the Route Planner returns, it simply gives the train a distance
		until it needs to stop. While this is more complicated to handle within
		the train, it makes the navigation code simple.

		Prediction
		==========
		When the Route Planner returns, a list of all nodes the train could possibly
		hit is returned. These predictions are forwarded on to the Detective with
		an estimated time window for hitting them.

		Reservations
		============
		The track is automatically reserved within the call to plan route. This 
		ensures that the train stays as simple as possible and can just focus on 
		driving and calibrating.
	
	UI / Shell
	==========
	Not much has changed with these two user tasks since they were mostly working
	for our Project 1 demo. The following is a list of the changes.

		UI
		==
		Since we are now tracking 2 trains, we will display the location of each
		train separately on the map.

		Shell
		=====
		During train calibration, the shell will now be blocked until a train is 
		fully calibrated.

	Error Codes
	===========
	We created the following error codes for the project:
		TIMEOUT,				// A timeout has occurred
		DET_INVALID_REQ_TYPE,	// Invalid Track Detective request type
		INVALID_NODE_NAME,		// Invalid node name
		INVALID_NODE_IDX,		// Invalid node index
		RP_INVALID_REQ_TYPE,	// Invalid request type for the Route Planner
		INVALID_SENSOR_IDX,		// Invalid sensor index
		INVALID_TRAIN_SPEED,	// Invalid train speed (avg speed)
		INVALID_TRACK			// Invalid track identifier
		NO_PATH					// There is no path for the train
	
	Whenever a server request is made, we always check for these error values
	in the reply. If there is an error, the user task should attempt to handle
	it.

	Neat Things
	===========
	We did some neat things for this assignment. Here's a brief discussion of
	some of them.
		
		- can travle to any location - not just sensors

		Track Measurements
		==================
		We measured the location of every single node on both tracks from an
		origin point. 

		Calibration Data
		================
		Kernel
		======
		Since we started working on the project, we have not modified our kernel.

	no global OR static vairables. Each class is completely self-contained. Reduces
	coupling.

	Except for the ROute PLanner and the Reservation system. It was more efficient to share the track model then to pass reservation data bck and forth in messages.

 ____ ____ ____ ____ ____ ____ ____ ____ _________ ____ 
||Q |||u |||e |||s |||t |||i |||o |||n |||       |||3 ||
||__|||__|||__|||__|||__|||__|||__|||__|||_______|||__||
|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/_______\|/__\|

	Here are the md5 hashes for each file:

 ____ ____ ____ ____ ____ ____ ____ ____ _________ ____ 
||Q |||u |||e |||s |||t |||i |||o |||n |||       |||4 ||
||__|||__|||__|||__|||__|||__|||__|||__|||_______|||__||
|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|/_______\|/__\|
	
	Here are all of the files we are submitting:


	Note: Extra compilation files may be included in the directories (.o, .s etc).
